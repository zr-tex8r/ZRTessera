#
#
#

=nop

                          -E  -J  -F
T-00 T_NRM 一般            F   F   F
T-01 T_OPR 開き括弧類      P   H   H
T-02 T_CPR 閉じ括弧類      P   H   H
T-03 T_MDL 中点類          ?   H   H
T-04 T_FST 句点類          P   H   H
T-05 T_USP 分離禁止文字
T-06 T_ESN 区切り約物
T-07 T_HYP ハイフン類

■ jlreq 文字クラス
cl-01 CL_OPR 始め括弧類      T_OPR
cl-02 CL_CPR 終わり括弧類    T_CPR
cl-03 CL_HYP ハイフン類      T_NRM+字幅
cl-04 CL_ESN 区切り約物      T_ESN
cl-05 CL_MDL 中点類          T_MDL
cl-06 CL_FST 句点類          T_FST
cl-07 CL_COM 読点類          T_CPR
cl-08 CL_USP 分離禁止文字    T_USP
cl-09 CL_REP 繰返し記号      T_NRM+禁則
cl-10 CL_LNG 長音記号        T_NRM+禁則
cl-11 CL_SKN 小書きの仮名    T_NRM+禁則
cl-12 CL_BSY 前置省略記号    T_NRM+xsp
cl-13 CL_ASY 後置省略記号    T_NRM+xsp
cl-14 CL_JSP 和字間隔        space
cl-15 CL_HKN 平仮名          T_NRM
cl-16 CL_KKN 片仮名          T_NRM
cl-17 CL_REL 等号類          T_NRM+xsp
cl-18 CL_BIN 演算記号        T_NRM+xsp
cl-19 CL_JLT 漢字等          T_NRM
cl-26 CL_ESP 欧文間隔        space
cl-27 CL_ELT 欧文用文字      欧文
※ 上の集合は互いに排他。例外として、
   2116 全角NO が cl-12 と cl-19 で重複。
[文脈定義を含むもの; * 印は文脈定義のみ]
cl-20 ------ *合印中の文字
cl-21 ------ *親文字群中の文字（添え字付き）
cl-22 ------ *親文字群中の文字（熟語ルビ以外のルビ付き）
cl-23 ------ *親文字群中の文字（熟語ルビ付き）
cl-24 ------ 連数字中の文字
cl-25 ------ 単位記号中の文字
cl-28 ------ 割注始め括弧類
cl-29 ------ 割注終わり括弧類
cl-30 ------ *縦中横中の文字

■ JIS X 4051 文字クラス
始め括弧類            1
終り括弧類            2
全角行頭禁則文字      0
区切り約物            6
中点類                3
句点類                4
分離禁止記号          5
前置記号              0
後置記号              0
(和字間隔)
上記以外の和字        0
(連数字中の文字)
(単位記号中の文字)
(欧文間隔)
(欧文間隔以外の欧文用文字)

=cut

use strict;
my $extref = $ENV{texlabo_extref} || "../../texdoc/extref";
my $jlreq_file = "$extref/jlreq/ja.htm";
my ($cc, @clist);
open(my $hi, '<', $jlreq_file) or die;
while (my $lin = <$hi>) {
  if ($lin =~ m|^\s*<h3><a id="cl-(\d+)"|) {
    $cc = $1 - 0;
  } elsif ($lin =~ m|^\s*<table class="charclass">|) {
    while ($lin =~ m|<tr><td rowspan="1" colspan="1">.{1,6}</td><td rowspan="1" colspan="1">([0-9A-F]{4})|g) {
      push(@{$clist[$cc]}, hex($1));
    }
  }
}
my @cnks;
#---------------------------------------------------------------------
push(@cnks, <<'END');
#
# ZRJLRClass.pm
# This module was generated by gen-ZRJLRClass.pl.
package ZRJLRClass;
use strict qw( refs vars subs );
require Exporter;
our @ISA = qw( Exporter );
our @EXPORT = qw(
  jlr_jclass jlr_evalid zr_type
  to_hw to_zw as_hw as_zw ord_hw ord_zw
  CL_OPR CL_CPR CL_HYP CL_ESN CL_MDL CL_FST CL_COM CL_USP
  CL_REP CL_LNG CL_SKN CL_BSY CL_ASY CL_JSP CL_HKN CL_KKN
  CL_REL CL_BIN CL_JLT CL_ESP CL_ELT
  T_NRM T_OPR T_CPR T_MDL T_FST T_USP T_ESN T_HYP
);
our @EXPORT_OK = qw( jlreq_cl );
use constant {
  CL_OPR =>  1, CL_CPR =>  2, CL_HYP =>  3, CL_ESN =>  4,
  CL_MDL =>  5, CL_FST =>  6, CL_COM =>  7, CL_USP =>  8,
  CL_REP =>  9, CL_LNG => 10, CL_SKN => 11, CL_BSY => 12,
  CL_ASY => 13, CL_JSP => 14, CL_HKN => 15, CL_KKN => 16,
  CL_REL => 17, CL_BIN => 18, CL_JLT => 19, CL_ESP => 26,
  CL_ELT => 27,
};
our @main_jclass = (
  CL_OPR, CL_CPR, CL_HYP, CL_ESN, CL_MDL, CL_FST, CL_COM, CL_USP,
  CL_REP, CL_LNG, CL_SKN, CL_BSY, CL_ASY, CL_HKN, CL_KKN, CL_REL,
  CL_BIN, CL_JLT
);
use constant {
  T_NRM => 0, T_OPR => 1, T_CPR => 2, T_MDL => 3,
  T_FST => 4, T_USP => 5, T_ESN => 6,
};
our %jlrc2zrt = (
  CL_OPR, T_OPR,  CL_CPR, T_CPR,  CL_HYP, T_NRM,  CL_ESN, T_ESN,
  CL_MDL, T_MDL,  CL_FST, T_FST,  CL_COM, T_CPR,  CL_USP, T_USP,
  CL_REP, T_NRM,  CL_LNG, T_NRM,  CL_SKN, T_NRM,  CL_BSY, T_NRM,
  CL_ASY, T_NRM,  CL_HKN, T_NRM,  CL_KKN, T_NRM,  CL_REL, T_NRM,
  CL_BIN, T_NRM,  CL_JLT, T_NRM,
);
our (%jlr_jclass, %jlr_evalid, @jlr_class_list);
sub jlr_jclass {
  (%jlr_jclass) or gen_jclass_map();
  return $jlr_jclass{$_[0]};
}
sub jlr_evalid {
  (%jlr_evalid) or gen_evalid_map();
}
sub zr_type {
  (%jlr_jclass) or gen_jclass_map();
  return $jlrc2zrt{$jlr_jclass{$_[0]}};
}
sub to_hw {
  my ($uc) = @_;
  return (0xFF01 <= $uc && $uc <= 0xFF5E) ? ($uc - 0xFEE0) : undef;
}
sub to_zw {
  my ($uc) = @_;
  return (0x21 <= $uc && $uc <= 0x7E) ? ($uc + 0xFEE0) : undef;
}
sub as_hw { return to_hw($_[0]) || $_[0]; }
sub ord_hw { return as_hw(ord($_[0])); }
sub as_zw { return to_zw($_[0]) || $_[0]; }
sub ord_zw { return as_zw(ord($_[0])); }
sub gen_jclass_map {
  foreach my $cn (@main_jclass) {
    my $cl = $jlr_class_list[$cn] or next;
    foreach my $uc (@$cl) { $jlr_jclass{$uc} = $cn; }
  }
  $jlr_jclass{0x2116} = 12; # resolving clash
}
sub gen_evalid_map {
  my $cl = $jlr_class_list[CL_ELT] or next;
  foreach my $uc (@$cl) { $jlr_evalid{$uc} = 1; }
}
@jlr_class_list = (
END
#---------------------------------------------------------------------
foreach $cc (0 .. $#clist) {
  my $cl = $clist[$cc];
  if (!defined $cl) { push(@cnks, "undef,\n"); next; }
  #-------------------------------------------------------------------
  push(@cnks, <<"END");
[ # $cc
END
  #-------------------------------------------------------------------
  foreach (@$cl) {
    push(@cnks, sprintf("0x%04X,\n", $_));
  }
  #-------------------------------------------------------------------
  push(@cnks, <<'END');
],
END
  #-------------------------------------------------------------------
}
#---------------------------------------------------------------------
push(@cnks, <<'END');
);
1;
# EOF
END
#---------------------------------------------------------------------
open(my $ho, '>', 'ZRJLRClass.pm') or die;
print $ho (@cnks);
close($ho);
# EOF
